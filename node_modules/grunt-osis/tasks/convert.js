/*
 * grunt-osis
 * https://github.com/matt-cook/grunt-osis
 *
 * Copyright (c) 2016 Matt Cook
 * Licensed under the MIT license.
 */
'use strict';

 module.exports = function(grunt) {

  var plist = require('plist');
  var YAML = require('yamljs');
  var path = require('path');
  var util = require('util');
  var csv = require('csv');
  var fs = require('fs');
  var async = require('async');

  grunt.registerMultiTask('convert', 'Convert from OSIS to Markdown', function() {

    //Tell grunt that this is an async task
    var done = this.async();

    var options = this.options({
      pretty: true,
      mergeAttrs: true,
      inline: 8,
      indent: 2,
      csv: {
        columns: true,
        delimiter: ','
      }
    });

    if (options.type && options.type.indexOf('.') === -1) {
      options.type = '.' + options.type;
    }

    grunt.verbose.writeflags(options, 'Options');

    async.forEach(this.files, function (f, next) {

      var handled = false;
      var finish = function() {
        if(!handled) {
          // Write the destination file.
          grunt.file.write(f.dest, data);
          next();
        }
      };

      if (f.src.length < 1) {
        // No src files, issued warn and goto next target.
        grunt.log.warn('Destination not written because no source files were found.');
        next();
        return;
      }

      var srcFiles = f.src.map(grunt.file.read).join(grunt.util.normalizelf(grunt.util.linefeed)),
          srcExt = options.type ||path.extname(f.src[0]),
          destExt = path.extname(f.dest),
          data = srcFiles;

      // source/destination same, goto next target.
      if (srcExt === destExt) {
        next();
        return;
      }

    if (srcExt === '.xml') {

        handled = true;
        var parse = require('xml2js').parseString;
        parse(srcFiles, options, function(err, result) {
          if (err) {
            grunt.fail.warn('File ' + f.dest.cyan + ' parsing errors: ' + err);
          }
          if (destExt === '.md') {
            var translation = f.dest.substring(0,f.dest.lastIndexOf(destExt));
            var b = result.osis.osisText.div; //books
            for(var i = 0; i < b.length; i++){
              var c = b[i].chapter;
              var basePath = translation + '/' + b[i].osisID + '/';
              for(var j = 0; j < c.length; j++){
                var body = '';
                var v = c[j].verse;
                for(var k = 0; k < v.length; k++){
                  body += '\n'+v[k]['_'];
                }
                data = '---\n'
                  + 'title: Chapter '+(j+1)+'\n'
                  + '---\n'
                  + '### Chapter '+(j+1)
                  + body;
                var path = (basePath + j + destExt).toLowerCase();
                grunt.file.write(path, data);
              }
            }
            finish();
            next();
          }else{
            data = JSON.stringify(result, null, options.indent);
            grunt.file.write(f.dest, data);
            finish();
            next();
          }
        });

      }

      finish();
      // Print a success message.
      grunt.log.ok('File ' + f.dest.cyan + ' converted.' + ' OK'.green);
    }, done);
  });

  var toXML = function xml(json, options) {

      var XML_CHARACTER_MAP = {
            '&': '&amp;',
            '"': '&quot;',
             "'": '&apos;',
            '<': '&lt;',
            '>': '&gt;'
          },
          result = options.header ? '<?xml version="1.0" encoding="UTF-8"?>' : '',
          type = json.constructor.name;

      options.header = false;

      if(type==='Array'){
        json.forEach(function(node){
          result += xml(node, options);
        });

      } else if(type ==='Object' && typeof json === "object") {

        Object.keys(json).forEach(function(key){
          if(key!==options.attrkey){
            var node = json[key],
            attributes = '';

            if(options.attrkey && json[options.attrkey]){
              Object.keys(json[options.attrkey]).forEach(function(k){
                attributes += util.format(' %s="%s"', k, json[options.attrkey][k]);
              });
            }
            var inner = xml(node,options);

            if(inner){
              result += util.format("<%s%s>%s</%s>", key, attributes, xml(node,options), key);
            } else {
              result += util.format("<%s%s/>", key, attributes);
            }
          }
        });
      } else {
        return json.toString()
        .replace(/([&"<>''])/g, function(str, item) {
          return XML_CHARACTER_MAP[item];
        });
      }

      return result;
    };
};
